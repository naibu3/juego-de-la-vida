;; Funcion que aplica una regla a un conjunto de celdas dado su vecindario
(define (apply-rule rule cells neighbourhoods)
  (map rule (neighbourhoods cells))
  )

;; Regla para conjuntos de celdas unidimensionales ciclicos, toma en cuenta los vecinos de la izquierda y derecha
(define (rule-90 neighbours)
  (let (
        (left (car neighbours))
        (right (cdr neighbours))
        )
    (cond ((and (= 1 left) (= 0 right))
           1
           )
          ((and (= 0 left) (= 1 right))
           1
           )
          (else 0)
          )
    )
  )

;; Construye los vecindarios a partir de un conjunto de celdas unidimensional y ciclico mediante la regla-90
(define (rule-90-neighbourhoods cells)
  (define sllec (reverse cells))
  (define left (reverse (append (list-tail sllec 1) (list (car sllec)))))
  (define right (append (list-tail cells 1) (list (car cells))))
  (map cons left right)
  )

;; Funcion para imprimir las celdas
(define (display-cells cells)
  (display (list->string (map (lambda (cell)
                                (if (= cell 1) #\* #\ )
                                )
                              cells)
                         )
           )
  )

;; Funcion que va aplicando la regla 90 de forma interactiva
(define (interactive-rule-90 cells)
  (display-cells cells)
  (if (not (eq? (read-char) #\q))
      (interactive-rule-90 (apply-rule rule-90 cells rule-90-neighbourhoods))
      )
  )

;; Crea una regla a traves de una tabla de correspondencias
(define (deterministic-rule table)
  (lambda (neighbours)
    (cadr (assoc neighbours table))
    )
  )

;; Regla 90 como tabla 
(define rule-90 (deterministic-rule '(((0 0) 0)
                                      ((0 1) 1)
                                      ((1 0) 1)
                                      ((1 1) 0))))

;; Traduce una lista de celdas a una cadena segun una tabla
(define (translate cells translation-table)
  (list->string (map (lambda (cell) (string-ref translation-table cell))
                     cells)))

;; Ejemplo de tabla para estados 0 ó 1
;(translate cells " *")

;; Funcion que traduce e imprime por terminal
(define (translate-and-display-1d cells translation-table)
  (display (translate cells translation-table))
  )

;; Agrupa los elementos de forma que tenemos el grupo de los primeros elementos de las listas de entrada, el grupo de los segundos elementos de las listas de entrada, el grupo de los terceros elementos de las listas de entrada...
(define (zip . lists)
  (apply map (cons list lists)))

(define (fold operator initial-value list1 . listn)
  (if (null? listn)
      (if (null? list1)
          initial-value
          (fold operator
                (operator (car list1) initial-value)
                (cdr list1)))
      (fold (lambda (lists accumulator)
              (apply operator (append lists (list accumulator))))
            initial-value
            (apply zip (cons list1 listn)))))

#|Esto es más o menos lo opuesto a fold: unfold.
A partir de unas funciones que indican cómo operar y un valor semilla, esta función crea una lista.
La función unfold acepta como argumentos un predicado stop? que indica si hay que parar, una función generate
que genera el siguiente elemento de la lista a partir de la semilla, una función update que actualiza el valor de la semilla
para la siguiente operación, un valor semilla seed que sirve para dar comienzo al trabajo y una función opcional tail
que sirve para crear la cola de la lista si queremos.|#

(define (unfold stop? generate update seed . tail)
  (define (accumulate current-seed current-list)
    (if (stop? current-seed)
        (reverse (if (null? tail)
                     current-list
                     (cons ((car tail) current-seed)
                           current-list)))
        (accumulate (update current-seed)
                    (cons (generate current-seed) current-list))))
  (accumulate seed '()))

;; Generar un rango de números entre dos extremos (el primero incluido y el último excluido) con un incremento que se pasa como argumento opcional y cuyo valor por defecto es la unidad
(define (range start end step)
  (define comparator (if (> end start) >= <=))
  (define (accumulate position accumulator)
    (if (comparator position end)
        (reverse accumulator)
        (accumulate (+ position step) (cons position accumulator))))
  (accumulate start '()))

#|productorios parciales: listas cuyos elementos son el primer elemento de una lista de entrada; el producto del primer elemento y el segundo elemento; el producto del primer elemento, el segundo elemento y el tercer elemento… Para ello, primero definiremos una función llamada cumulative-map que aceptará un operador operator (una función) de dos argumentos, un valor inicial initial-value (que sería normalmente el elemento identidad del operador) y una lista sequence sobre la que aplicar el operador desde el primer elemento hasta el último. Lo haremos con fold:|#
(define (cumulative-map operator initial-value sequence)
  (define (accumulate item accumulator)
    (cons (operator item (car accumulator)) accumulator))
  (reverse (fold accumulate
                 (list (operator initial-value (car sequence)))
                 (cdr sequence))))

;; generador de listas de productos parciales
(define (cumulative-product sequence)
  (cumulative-map * 1 sequence))

;; De 1 dimension a varias
(define (flat->multidimensional sizes index)
  (define strides
    (reverse (cons 1 (if (= (length sizes) 1)
                         '()
                         (cumulative-product (reverse (cdr sizes)))))))
  (define current-index car)
  (define current-stride cadr)
  (define strides-list cdr)
  (unfold (lambda (index-and-strides)
            (null? (strides-list index-and-strides)))
          (lambda (index-and-strides)
            (floor (/ (current-index index-and-strides)
                      (current-stride index-and-strides))))
          (lambda (index-and-strides)
            (cons (modulo (current-index index-and-strides)
                          (current-stride index-and-strides))
                  (cdr (strides-list index-and-strides))))
          (cons index strides)))

;; De varias dimensiones a una
(define (multidimensional->flat sizes indices)
  (fold (lambda (index size accumulator)
          (+ (* size accumulator) (modulo index size)))
        0 indices sizes))

#|La función admite como parámetros una lista sizes con los tamaños de las diferentes dimensiones, una lista indices1 con los índices que son el primer sumando y una lista indices2 con los índices que son el segundo sumando. El resultado es una lista con el conjunto de índices suma módulo cada dimension del primer conjunto de índices y el segundo conjunto de índices.|#
(define (cyclic-addition sizes indices1 indices2)
  (map (lambda (size index1 index2)
         (modulo (+ index1 index2) size))
       sizes indices1 indices2))

#|acepta una lista plana matrix, una lista sizes de tamaños de dimensiones y una lista indices de índices multidimensionales y devuelve el elemento de la lista plana matrix correspondiente a los índices especificados.|#
(define (matrix-ref matrix sizes indices)
  (list-ref matrix
            (multidimensional->flat sizes indices)))

#|aceptará una lista de celdas cells, una lista de tamaños de las distintas dimensiones sizes y una especificación de las posiciones relativas de los vecinos offsets. Este último parámetro nos da una forma muy compacta de especificar cómo son los vecindarios: se trata de una lista cuyos elementos son a su vez listas con los índices relativos al actual de los vecinos; por ejemplo, en un autómata bidimensional en que el primer índice va según el eje arriba-abajo (índices pequeños arriba, índices grandes abajo) y el segúndo índice va según el eje izquierda-derecha (índices pequeños a la izquierda, índices grandes a la derecha), la especificación ((-1 0) (1 0) (0 1) (-1 0)) daría como vecindario la celda de arriba, la de abajo, la de la derecha y la de la izquierda.|#
(define (cyclic-cartesian-neighbourhoods cells sizes offsets)
  (define (neighbour indices offset)
    (matrix-ref cells sizes (cyclic-addition sizes indices offset)))
  (define (neighbourhood indices)
    (map (lambda (offset) (neighbour indices offset))
         offsets))
  (define indices
    (map (lambda (flat-index) (flat->multidimensional sizes flat-index))
         (range 0 (length cells) 1)))
  (map neighbourhood indices))

;(interactive-rule-90 '(0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0))
(cyclic-cartesian-neighbourhoods '(11 12 13 21 22 23 31 32 33)
                                 '(3 3)
                                 '((-1 0) (0 1)))